# No equality constraints by now, all the constraints are of type <=:
#     constraints of type >= must be transformed in constaints of type
#     <= by changing the sign of the resource quantity, such as for Qlatency
# The application is represented with a list of components ( name 
#     of components are not important ), each of which is constituted
#     by a dictionary of couple { resource name, minimum quantity requested }  
# Every link is directed, and is reported in an adjacency list 
#     after every component, indicated with the special key 'links'
# Every number in the dictionary 'links' represents the position 
#     of the component with which it communicates; it is a dictionary 
#     of resources attached to the communication link and required by
#     the component on that link.
# If a resource name start with Q, it is considered a QoS indicator: they will 
#     be confrontated directly with the availability of the resource separately, 
#     instead of doing a summation of them 
---
- memory: 256
  VCPU: 100
  storage: 50
  links:
      1:
        Qlatency: -20
        bandwidth: 100
      2: 
        Qlatency: -100
- memory: 1024
  VCPU: 6
  links:
      0:
        Qlatency: -300        
- memory: 16384
  VCPU: 50
  storage: 100000
  SG: 2
  links:
- memory: 256
  VCPU: 5
  links:
...